

- 동적 계획법의 가장 일반적인 사용처는 최적화 문제의 해결임
-> 6.7절에서도 다뤘듯이 최적화 문제란 여러 개의 가능한 답 중 
    가장 좋은 답(최적해)을 찾아내는 문제를 말함
-> 사실 동적 계획법은 처음에 최적화 문제의 해답을 빨리 찾기 위해
    노력하는 과정에서 고안되었으며,
    때문에 많은 교과서에서 동적 계획법을 논의할 때
    최적화 과정을 가장 부각시켜 설명함
-> 최적화 문제를 동적 계획법으로 푸는 것 또한 완전 탐색에서 시작합니다만,
    최적화 문제에 특정 성질이 성립할 경우에는 단순히 메모이제이션을 적용하기보다
    좀 더 효율적으로 동적 계획법을 구현할 수 있음
-> 이 절에서는 이러한 성질들이 성립하는 몇 가지 예제를 보여줌

- 한 번에 한 칸씩 아래로 내려가 맨 아래줄까지 닿는 경로를 만듦
-> 경로는 아래줄로 내려갈때 마다 바로 아래 숫자 혹은 오른쪽 아래 숫자로 내려갈 수 있음
->



- 가장 먼저 완전 탐색을 통해 문제를 해결해 봄
-> 경로를 각 가로줄로 조각 낸 뒤, 각 조각에서는 아래로 내려갈지 오른쪽으로 내려갈지 선택하면서
   모든 경로를 만듦(7/6)
-> 이 때, 재귀 호출 함수에는 현재 위치와 지금까지 만난 숫자들의 합을 전달함
-> 그러면 다음과 같은 부분 문제를 얻을 수 있음(7/6)

- 가로줄이 하나 늘어날 때마다 두 배씩 늘어남
-> n개의 가로줄이 있을 때, 가능한 경로는 2의 n-1승

- 코드 8.8은 아까의 점화식을 구현한 완전 탐색에 메모이제이션을 적용한 것임
-> 이 코드는 멀쩡해 보이지만 알고 보면 중대한 문제가 있음
-> 첫 번째 문제는 사용해야 하는 메모리가 너무 크다는 것임
-> 배열의 크기가 입력으로 주어지는 숫자의 범위에 좌우됨(7/6)

- 또 다른 문제는 path1()이 특정 입력에 대해서는 완전 탐색처럼 동작한다는 것임
-> 그림 8.6(b)와 같이 2i꼴의 숫자로만 구성된 삼각형이 있다고 함
-> 이 때, 서로 다른 경로는 합도 항상 다름
-> 똑같은 (y,x) 위치까지 내려왔다고 해도 경로마다 다 다른 합을 가지니 
   같은 계산을 두 번 할 일이 없음
-> 이래서는 완전 탐색과 다를 바가 없음(7/6)


### 입력 걸러내기

- 이 알고리즘을 더 빠르게 하는 힌트는 재귀 함수의 입력을 다음과 같이 두 부류로 나눠 보면 얻을 수 있음
(1) y와 x는 재귀 호출이 풀어야 할 부분 문제를 지정함
-> 이 두 입력이 정해지면 앞으로 우리가 만들 수 있는 경로들이 정해짐
-> 따라서 이들은 앞으로 풀어야 할 조각들에 대한 정보를 주는 입력들임(7/6)

(2) 반면, sum은 지금까지 어떤 경로로 이 부분 문제에 도달했는지를 나타냄
-> sum은 지금까지 풀었던 조각들에 대한 정보를 주는 입력임(7/6)

- 다시 말하면 (y,x)는 그림 오른쪽에 아직 해결하지 못한 조각들을 정의하는 입력임
-> 그런데 과연 sum이 앞으로 남은 조각들을 푸는데 필요할까?
-> (y,x)에서 맨 아래줄까지 내려가는 최대 경로는 sum이 얼마 건 상관 없이 똑같음(7/6)
-> 재귀 함수에 sum을 아예 입력으로 받지 않도록 하면 이 알고리즘은 훨씬 빨라짐(7/6)

